Package ufs.compiladores.x;

/* as constantes utilizadas */
Helpers
	
	tudo = [0 .. 0xffff];
	
	/* Caracteres de espaço */
	carriage_return = 13;
	line_feed = 10;
	linha_fim = carriage_return | line_feed | carriage_return line_feed;
	tab = 9;
	nao_linha_fim = [tudo -[line_feed + carriage_return]];
	underscore = '_';
	
	/* Digitos e letras */

	digito = ['0'..'9'];
	letra = ['a'..'z'] | ['A' ..'Z'];
	hexa = ['a'..'f'] | ['A' .. 'F'];
	sem_asterisco = [tudo - '*'];
	op = '+' | '-';
	base = 'e' | 'E';
	
	
/* Os tokens e as expressões regulares necessárias */
Tokens

	/* Palavras reservadas */
	
	real = 'real';
	int  = 'int';
	bool = 'bool';
	true = 'true';
	false = 'false';
	if = 'if';
	then = 'then';
	else = 'else';
	while = 'while';
	procedure = 'procedure';
	function = 'function';
	cons = 'cons';
	var = 'var';
	
	/*Operadores*/
	
	atri = ':=';
	divisao = '/';
	mais = '+';
	menos = '-';
	mult = '*';
	mod = '%';
	menor = '<';
	igual = '=';
	and = 'and';
	or = 'or';
	neg = '!';
	pipe = '|';
	
	/*Delimitadores*/

	colchete_e = '[';
	colchete_d = ']';
	chave_e = '{';
	chave_d = '}';
	par_e = '(';
	par_d = ')';
	ponto_virgula = ';';
	virgula = ',';
	espaco = (linha_fim | tab | ' ')+;
	coment_linha = '//'(nao_linha_fim)*;
	/* Conversão de um autômato degeneralizado para uma expressão regular, o autômato encontra-se na página 53 do livro do Louden. */
	coment_bloco = '/*' sem_asterisco* '*'+ ([sem_asterisco - '/'] sem_asterisco* '*'+)* '/';
	
	/* Identificadores (letras, números) */
	
	id = (underscore)*letra(letra | digito | underscore)*;
	numero_inteiro = (op? '0x'(hexa | digito)+)? | op? digito+;
	numero_real = (op?)digito+('.'digito+)?(base(op)?digito+)?;

/* tokens que devem ser ignorados na varredura, espaço em branco, comentários.... */
Ignored Tokens
	espaco, coment_bloco, coment_linha;
	


Productions
	inicio_programa = programa;
	programa =  {dec_variavel_rec} programa dec_var 
				| {dec_variavel_unico} dec_var 
				| {dec_constante_rec} programa dec_const 
				| {dec_constante_unico} dec_const 
				| {dec_procedimento_rec} programa dec_procedimento 
				| {dec_procedimento_unico} dec_procedimento 
				| {dec_funcao_rec} programa dec_funcao 
				| {dec_funcao_unico} dec_funcao;
	
	
	
	dec_var = T.var tipo opcao_var cont_opcao_var* T.ponto_virgula;
	dec_const = T.cons tipo inicializacao cont_inicializacao* T.ponto_virgula;
	inicializacao = T.id T.atri exp;
	cont_inicializacao = T.virgula inicializacao;
	array_ext = T.colchete_e exp cont_exp* T.colchete_d;
	array_comp = T.colchete_e T.id T.pipe cont_array_comp T.colchete_d;
	cont_array_comp = {array_comp_escolha} array_comp | {exp_escolha} exp;
	
	tipo = {tipo_base} tipo_base | {tipo_composto} tipo T.colchete_e exp T.colchete_d;
	tipo_base = {int} T.int | {bool} T.bool | {real} T.real;
	dec_procedimento = T.procedure T.id T.par_e parametros T.par_d comando; 
	dec_funcao = T.function tipo T.id T.par_e parametros T.par_d exp;
	parametros = {vazio} | parametro parametro_cont*;
	parametro = T.var? tipo_parametro T.id;
	tipo_parametro = {tipo_base_param} tipo_base | {tipo_param_cont} tipo_parametro T.colchete_e T.colchete_d;
	parametro_cont = T.ponto_virgula parametro;
	comando =   {comando_if} comandos_if 
			  | {comando_while} T.while T.par_e exp T.par_d comando 
			  | {comando_var} P.var T.atri exp T.ponto_virgula 
			  | {comando_chamada} chamada T.ponto_virgula 
			  | {comando_bloco} bloco; /* implementar sem ambiguidade */
	
	comandos_if ={if_sem_else} T.if T.par_e exp T.par_d T.then comando 
	           | {if_com_else} T.if T.par_e exp T.par_d T.then if_com_else T.else comando;
	if_com_else = comando_com_else;
	if_com_else2 = comando_com_else;
	comando_com_else = T.if T.par_e exp T.par_d T.then if_com_else T.else if_com_else2;
	
	bloco = T.chave_e cont_bloco T.chave_d;
	opcao_bloco = {op_dec_var} dec_var | {op_dec_const} dec_const | {op_comando} comando;
	cont_bloco = {cont_bloco} cont_bloco opcao_bloco | {base_cont_bloco} opcao_bloco;
	var = {id_variavel} T.id |{comando_var_rec} P.var T.colchete_e exp T.colchete_d;
	
	exp = {teste} T.then T.id; /*implementar sem ambiguidade */
	cont_exp = T.ponto_virgula exp;
	
	if_exp = T.if T.par_e exp T.par_d then_parte else_parte;
	then_parte = T.then exp;
	else_parte = T.else exp;
	
	chamada = T.id T.par_e lista_exp T.par_d;
	
	lista_exp = {vazio} | {lista_exp} exp cont_exp*;
		
	opcao_var = {id} T.id | {inicializacao} inicializacao;
	cont_opcao_var = T.virgula opcao_var;
