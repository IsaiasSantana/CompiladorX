Package ufs.compiladores.x;

/* as constantes utilizadas */
Helpers
	
	tudo = [0 .. 0xffff];
	
	/* Caracteres de espaço */
	carriage_return = 13;
	line_feed = 10;
	linha_fim = carriage_return | line_feed | carriage_return line_feed;
	tab = 9;
	nao_linha_fim = [tudo -[line_feed + carriage_return]];
	underscore = '_';
	
	/* Digitos e letras */

	digito = ['0'..'9'];
	letra = ['a'..'z'] | ['A' ..'Z'];
	hexa = ['a'..'f'] | ['A' .. 'F'];
	sem_asterisco = [tudo - '*'];
	op = '+' | '-';
	base = 'e' | 'E';
	
	
/* Os tokens e as expressões regulares necessárias */
Tokens

	/* Palavras reservadas */
	
	real = 'real';
	int  = 'int';
	bool = 'bool';
	true = 'true';
	false = 'false';
	if = 'if';
	then = 'then';
	else = 'else';
	while = 'while';
	procedure = 'procedure';
	function = 'function';
	cons = 'cons';
	var = 'var';
	
	/*Operadores*/
	
	atri = ':=';
	divisao = '/';
	mais = '+';
	menos = '-';
	mult = '*';
	mod = '%';
	menor = '<';
	igual = '=';
	and = 'and';
	or = 'or';
	neg = '!';
	pipe = '|';
	
	/*Delimitadores*/

	colchete_e = '[';
	colchete_d = ']';
	chave_e = '{';
	chave_d = '}';
	par_e = '(';
	par_d = ')';
	ponto_virgula = ';';
	virgula = ',';
	espaco = (linha_fim | tab | ' ')+;
	coment_linha = '//'(nao_linha_fim)*;
	/* Conversão de um autômato degeneralizado para uma expressão regular, o autômato encontra-se na página 53 do livro do Louden. */
	coment_bloco = '/*' sem_asterisco* '*'+ ([sem_asterisco - '/'] sem_asterisco* '*'+)* '/';
	
	/* Identificadores (letras, números) */
	
	id = (underscore)*letra(letra | digito | underscore)*;
	numero_inteiro = (op? '0x'(hexa | digito)+)? | op? digito+;
	numero_real = (op?)digito+('.'digito+)?(base(op)?digito+)?;

/* tokens que devem ser ignorados na varredura, espaço em branco, comentários.... */
Ignored Tokens
	espaco, coment_bloco, coment_linha;
	


Productions
	inicio_programa = {programa} programa+ |{vazio} vazio;
	vazio = {vazio} ;
	programa =   {dec_variavel_unico} dec_var  
				| {dec_constante_unico} dec_const  
				| {dec_procedimento_unico} dec_procedimento 
				| {dec_funcao_unico} dec_funcao;
	
	
	
	dec_var = T.var tipo opcao_var cont_opcao_var* T.ponto_virgula;
	dec_const = T.cons tipo inicializacao cont_inicializacao* T.ponto_virgula;
	inicializacao = {atri_exp_ini} T.id T.atri exp 
				  | {atri_ini_array_ext} T.id T.atri array_ext 
				  | {atri_ini_array_comp} T.id T.atri array_comp;
				  
	cont_inicializacao = T.virgula inicializacao;
	array_ext = T.colchete_e exp cont_exp* T.colchete_d;
	array_comp = T.colchete_e T.id T.pipe cont_array_comp T.colchete_d;
	cont_array_comp = {array_comp_escolha} array_comp | {exp_escolha} exp;
	
	tipo = {tipo_base} tipo_base | {tipo_composto} tipo T.colchete_e exp T.colchete_d;
	tipo_base = {int} T.int | {bool} T.bool | {real} T.real;
	dec_procedimento = T.procedure T.id T.par_e parametros T.par_d comando; 
	dec_funcao = T.function tipo T.id T.par_e parametros T.par_d exp;
	parametros = {param_vazio} vazio| parametro parametro_cont;
	parametro = T.var? tipo_parametro T.id;
	tipo_parametro = {tipo_base_param} tipo_base | {tipo_param_cont} tipo_parametro T.colchete_e T.colchete_d;
	parametro_cont = {parametro_cont_rec} parametro_cont T.virgula parametro |{parametro_cont_vazio} vazio;
	comando =   {if_then} T.if T.par_e exp T.par_d T.then comando
			  | {if_else} T.if T.par_e exp T.par_d T.then comando2 T.else comando 	
			  | {comando_while} T.while T.par_e exp T.par_d comando 
			  | {comando_var} P.var T.atri exp T.ponto_virgula 
			  | {comando_chamada} chamada T.ponto_virgula 
			  | {comando_bloco} bloco;
			  
	
	comando2 =  {if_else2} T.if T.par_e exp T.par_d T.then [caso_true]:comando2 [caso_false]:else_parte2 	
			  | {comando_while2} T.while T.par_e exp T.par_d comando2 
			  | {comando_var2} P.var T.atri exp T.ponto_virgula 
			  | {comando_chamada2} chamada T.ponto_virgula 
			  | {comando_bloco2} bloco;
	
	else_parte2 = T.else comando2;

	
	
	
	bloco = T.chave_e cont_bloco T.chave_d;
	opcao_bloco = {op_dec_var} dec_var | {op_dec_const} dec_const | {op_comando} comando;
	cont_bloco = {cont_bloco}  opcao_bloco*;
	
	bloco2 = T.chave_e cont_bloco2 T.chave_d;
	opcao_bloco2 = {op_dec_var2} dec_var | {op_dec_const2} dec_const | {op_comando2} comando2;
	cont_bloco2 = {cont_bloco2}  opcao_bloco2*;
	
	var = {id_variavel} T.id |{comando_var_rec} P.var T.colchete_e exp T.colchete_d;
	
	exp = {exp_or} exp_or | {if_exp} if_exp | {bloco_exp} bloco_exp; /*implementar sem ambiguidade */
	exp_or = {operacao_or} exp_or T.or exp_and |{para_op_and} exp_and;
	exp_and = {operacao_and} exp_and T.and op_igual | {para_op_igual} op_igual;
	op_igual = {operacao_igual} op_igual T.igual operacao_menor | {para_operacao_menor} operacao_menor;
	operacao_menor = {operacao_menor} operacao_menor T.menor operacao_soma_sub | {para_operacao_soma_sub} operacao_soma_sub;
	operacao_soma_sub = {operacao_soma} operacao_soma_sub T.mais operacao_div_mul_mod 
						| {operacao_subtracao} operacao_soma_sub T.menos operacao_div_mul_mod
						| {para_operacao_div_mul_mod} operacao_div_mul_mod;
						
	operacao_div_mul_mod = {operacao_divisao} operacao_div_mul_mod T.divisao operacao_unaria 
							| {operacao_modulo} operacao_div_mul_mod T.mod operacao_unaria
							| {operacao_multiplicacao} operacao_div_mul_mod T.mult operacao_unaria
							| {para_operacao_unaria} operacao_unaria;
							
	operacao_unaria = {operacao_neg} T.neg operacao_unaria 
					  | {opercao_menos_unaria} T.menos operacao_unaria
					  | {para_inicio_rec_exp} rec_exp;
					  
	rec_exp =  {rec_exp_parenteses} T.par_e exp T.par_d 
	          |  {exp_numero_inteiro} T.numero_inteiro 
	          |  {numero_real} T.numero_real 
	          | {true} T.true 
	          | {false} T.false
	          | {chamada} chamada
	          | {variavel} P.var; 
	          
	cont_exp = T.virgula exp;
	bloco_exp = T.chave_e dec_const* exp T.chave_d;
	
	if_exp = T.if T.par_e exp T.par_d then_parte else_parte;
	then_parte = T.then exp;
	else_parte = T.else exp;
	
	chamada = T.id T.par_e lista_exp T.par_d;
	
	lista_exp = {list_vazio} vazio| {lista_exp} exp cont_exp*;
		
	opcao_var = {id} T.id | {inicializacao} inicializacao;
	cont_opcao_var = T.virgula opcao_var; 