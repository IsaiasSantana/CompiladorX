Package ufs.compiladores.x;

/* as constantes utilizadas */
Helpers
	
	tudo = [0 .. 0xffff];
	
	/* Caracteres de espaço */
	carriage_return = 13;
	line_feed = 10;
	linha_fim = carriage_return | line_feed | carriage_return line_feed;
	tab = 9;
	nao_linha_fim = [tudo -[line_feed + carriage_return]];
	underscore = '_';
	
	/* Digitos e letras */

	digito = ['0'..'9'];
	letra = ['a'..'z'] | ['A' ..'Z'];
	hexa = ['a'..'f'] | ['A' .. 'F'];
	sem_asterisco = [tudo - '*'];
	op = '+' | '-';
	base = 'e' | 'E';
	
	
/* Os tokens e as expressões regulares necessárias */
Tokens

	/* Palavras reservadas */
	
	real = 'real';
	int  = 'int';
	bool = 'bool';
	true = 'true';
	false = 'false';
	if = 'if';
	then = 'then';
	else = 'else';
	while = 'while';
	procedure = 'procedure';
	function = 'function';
	cons = 'cons';
	var = 'var';
	
	/*Operadores*/
	
	atri = ':=';
	divisao = '/';
	mais = '+';
	menos = '-';
	mult = '*';
	mod = '%';
	menor = '<';
	igual = '=';
	and = 'and';
	or = 'or';
	neg = '!';
	pipe = '|';
	
	/*Delimitadores*/

	colchete_e = '[';
	colchete_d = ']';
	chave_e = '{';
	chave_d = '}';
	par_e = '(';
	par_d = ')';
	ponto_virgula = ';';
	virgula = ',';
	espaco = (linha_fim | tab | ' ')+;
	coment_linha = '//'(nao_linha_fim)*;
	/* Conversão de um autômato degeneralizado para uma expressão regular, o autômato encontra-se na página 53 do livro do Louden. */
	coment_bloco = '/*' sem_asterisco* '*'+ ([sem_asterisco - '/'] sem_asterisco* '*'+)* '/';
	
	/* Identificadores (letras, números) */
	
	id = (underscore)*letra(letra | digito | underscore)*;
	numero_inteiro = (op? '0x'(hexa | digito)+)? | op? digito+;
	numero_real = (op?)digito+('.'digito+)?(base(op)?digito+)?;

/* tokens que devem ser ignorados na varredura, espaço em branco, comentários.... */
Ignored Tokens
	espaco, coment_bloco, coment_linha;
	


Productions
	inicio_programa = programa;
	programa =  {dec_variavel_rec} programa dec_var 
				| {dec_variavel_unico} dec_var 
				| {dec_constante_rec} programa dec_const 
				| {dec_constante_unico} dec_const 
				| {dec_procedimento_rec} programa dec_procedimento 
				| {dec_procedimento_unico} dec_procedimento 
				| {dec_funcao_rec} programa dec_funcao 
				| {dec_funcao_unico} dec_funcao;
	
	
	
	dec_var = T.var tipo opcao_var cont_opcao_var* T.ponto_virgula;
	dec_const = T.cons tipo inicializacao cont_inicializacao* T.ponto_virgula;
	inicializacao = T.id T.atri exp;
	cont_inicializacao = T.virgula inicializacao;
	array_ext = T.colchete_e exp cont_exp* T.colchete_d;
	array_comp = T.colchete_e T.id T.pipe cont_array_comp T.colchete_d;
	cont_array_comp = {array_comp_escolha} array_comp | {exp_escolha} exp;
	
	tipo = {tipo_base} tipo_base | {tipo_composto} tipo T.colchete_e exp T.colchete_d;
	tipo_base = {int} T.int | {bool} T.bool | {real} T.real;
	dec_procedimento = T.procedure T.id T.par_e parametros T.par_d comando; 
	dec_funcao = T.function tipo T.id T.par_e parametros T.par_d exp;
	parametros = {vazio} | parametro parametro_cont*;
	parametro = T.var? tipo_parametro T.id;
	tipo_parametro = {tipo_base_param} tipo_base | {tipo_param_cont} tipo_parametro T.colchete_e T.colchete_d;
	parametro_cont = T.ponto_virgula parametro;
	comando = {por_enquanto_vazio}; /* implementar sem ambiguidade */
	opcao_var = {id} T.id | {inicializacao} inicializacao;
	cont_opcao_var = T.virgula opcao_var;

	exp = {vazio}; /*implementar sem ambiguidade */
	cont_exp = T.ponto_virgula exp;